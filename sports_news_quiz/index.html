<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buyout Bash - The Running Game</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        /* Custom styles for the game container and canvas */
        .game-container {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 1024px;
            margin-left: auto;
            margin-right: auto;
            overflow: hidden; /* Prevent images from sticking out */
            background-color: #fff;
        }
        canvas {
            display: block;
            background-color: #f9fafb; /* Light background for the track */
            border-bottom: 4px solid #374151; /* The ground line */
            touch-action: manipulation; /* Improves touch handling */
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="game-container rounded-xl">
        <div class="p-4 bg-gray-900 text-white rounded-t-xl">
            <h1 class="text-3xl font-extrabold tracking-tight">üèà Buyout Bash</h1>
            <p class="text-sm opacity-75">Dodge those buyouts! Press **Space** or **Tap** to Jump.</p>
        </div>
        
        <div class="relative">
            <!-- Game Canvas -->
            <canvas id="gameCanvas" width="900" height="300" class="w-full"></canvas>

            <!-- Score Display -->
            <div id="scoreDisplay" class="absolute top-2 right-4 text-2xl font-black text-gray-700">SCORE: 0</div>
            
            <!-- Game Over / Start Message Box -->
            <div id="messageBox" class="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-70 transition-opacity duration-300">
                <div class="bg-white p-8 rounded-lg shadow-2xl text-center">
                    <p class="text-4xl font-extrabold text-red-600 mb-4" id="messageTitle">PRESS SPACE TO START</p>
                    <p class="text-lg text-gray-700" id="messageBody">Dodge the obstacles for the highest buyout score.</p>
                    <button id="restartButton" class="hidden mt-4 px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition transform hover:scale-105">RESTART</button>
                </div>
            </div>
        </div>
    </div>

    <!-- The main game script -->
    <script>
        // --- 1. GAME CONFIGURATION (Based on JSON) ---
        const GAME_CONFIG = {
            gameTitle: "Buyout Bash",
            player: {
                id: "player_character",
                name: "Matt Rhule",
                // Placeholder images are replaced with the actual access IDs
                image: "uploaded:rhule_headshot.jpg-e0f950d9-c647-4f81-a791-8b71e281075d",
                initialPosition: { x: 100, y: 500 }, // Y is calculated dynamically later
                width: 80,
                height: 80, // Reduced height for better visibility
                jumpHeight: 180,
                jumpSpeed: 10
            },
            obstacles: [
                { id: "obstacle_pennstate", name: "PSU Nittany Lion", image: "uploaded:psu_logo.png-66bbe6ee-ad3b-4d79-9c7b-5ab7a788baed", width: 70, height: 70, type: "ground", speedFactor: 1.0 },
                { id: "obstacle_lsu", name: "LSU Tiger", image: "uploaded:lsu_tiger.png-c04118d0-5d0f-4bdf-a6d4-8aece67c49d2", width: 80, height: 80, type: "ground", speedFactor: 1.1 },
                { id: "obstacle_auburn", name: "Auburn AU", image: "uploaded:auburn_logo.png-c6101724-ed52-4002-8f1b-3c024f746b18", width: 60, height: 60, type: "ground", speedFactor: 1.05 },
                { id: "obstacle_ucla", name: "UCLA Bruins", image: "uploaded:ucla_bear.jpg-c4ea4cae-423f-4dae-b8e0-6bf1fc50d636", width: 90, height: 75, type: "ground", speedFactor: 1.15 },
                { id: "obstacle_florida", name: "Florida Gators", image: "uploaded:florida_logo.jpg-777b0f5b-340b-4a11-984b-5156f7bc0a81", width: 95, height: 65, type: "ground", speedFactor: 1.2 }
            ],
            gameSettings: {
                initialGameSpeed: 6,
                speedIncreaseRate: 0.001, // Gradual increase per frame
                maxGameSpeed: 18,
                obstacleSpawnIntervalMin: 120, // Min frames between spawns
                obstacleSpawnIntervalMax: 220, // Max frames between spawns
            }
        };

        // --- 2. SETUP & INITIALIZATION ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageBody = document.getElementById('messageBody');
        const restartButton = document.getElementById('restartButton');

        let isGameRunning = false;
        let isGameOver = false;
        let gameFrame = 0;
        let score = 0;
        let gameSpeed = GAME_CONFIG.gameSettings.initialGameSpeed;
        let assetsLoaded = false;
        const assets = {};
        let player;
        let obstacles = [];
        let nextObstacleFrame = 0;

        let GROUND_Y = 0; // The Y position for the ground line (calculated from canvas height)

        /**
         * Converts the file ID into a useable image element.
         * @param {string} filename The name of the file to load.
         * @returns {Promise<HTMLImageElement>} A promise that resolves to an image element.
         */
        function loadImage(filename) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.error(`Failed to load image: ${filename}. Using placeholder.`);
                    // Fallback: Create a simple grey box if the image fails to load
                    const fallbackCanvas = document.createElement('canvas');
                    fallbackCanvas.width = 100;
                    fallbackCanvas.height = 100;
                    const ftx = fallbackCanvas.getContext('2d');
                    ftx.fillStyle = '#9ca3af'; // Gray
                    ftx.fillRect(0, 0, 100, 100);
                    resolve(fallbackCanvas);
                };
                img.src = filename;
            });
        }

        /** Loads all necessary image assets before starting the game. */
        async function loadAssets() {
            try {
                // Load Player Asset
                assets.player = await loadImage(GAME_CONFIG.player.image);

                // Load Obstacle Assets
                for (const obs of GAME_CONFIG.obstacles) {
                    assets[obs.id] = await loadImage(obs.image);
                }

                // --- NEW: Initialize player once assets are ready ---
                handleResize(); // Ensure GROUND_Y is set before creating Player
                player = new Player(GAME_CONFIG.player);
                // ---------------------------------------------------

                assetsLoaded = true;
                messageTitle.textContent = "PRESS SPACE OR TAP TO START";
            } catch (error) {
                console.error("Asset loading failed:", error);
                messageTitle.textContent = "ASSET LOAD ERROR";
                messageBody.textContent = "Check console for details.";
            }
        }

        /** Handles canvas resizing to ensure responsiveness. */
        function handleResize() {
            // Keep a consistent aspect ratio or dynamic height based on the container width.
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = containerWidth;
            canvas.height = Math.min(containerWidth * (300 / 900), 400); // Max height 400px

            // Recalculate GROUND_Y based on the new canvas height
            GROUND_Y = canvas.height - 4; // 4 is the border width from CSS
            
            // If player exists, update their ground position
            if (player) {
                player.groundY = GROUND_Y - player.height;
                // Only move player if they are on the ground (to prevent mid-air movement)
                if (!player.isJumping) {
                    player.y = player.groundY;
                }
            }
        }
        
        // Initial setup calls
        window.onload = () => {
            // Note: handleResize is called inside loadAssets to ensure player initialization is correct.
            loadAssets();
            window.addEventListener('resize', handleResize);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('touchstart', handleTouch);
            restartButton.addEventListener('click', startGame);
        };


        // --- 3. GAME CLASSES ---

        class Player {
            constructor(config) {
                this.width = config.width;
                this.height = config.height;
                this.x = config.initialPosition.x;
                this.groundY = GROUND_Y - this.height; // Updated dynamically by handleResize
                this.y = this.groundY;
                this.jumpVelocity = 0;
                this.isJumping = false;
                this.jumpHeight = config.jumpHeight;
                this.jumpSpeed = config.jumpSpeed;
                this.image = assets.player;
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            update() {
                if (this.isJumping) {
                    this.y += this.jumpVelocity;
                    this.jumpVelocity += 0.5; // Gravity

                    // Land the player
                    if (this.y >= this.groundY) {
                        this.y = this.groundY;
                        this.isJumping = false;
                        this.jumpVelocity = 0;
                    }
                }
            }

            jump() {
                if (!this.isJumping && isGameRunning) {
                    this.isJumping = true;
                    // Calculate the initial upward velocity needed to reach jumpHeight
                    // V_initial = -sqrt(2 * g * h) where g=0.5 (our gravity) and h=jumpHeight
                    this.jumpVelocity = -Math.sqrt(2 * 0.5 * this.jumpHeight);
                }
            }
        }

        class Obstacle {
            constructor(config) {
                this.config = config;
                this.width = config.width;
                this.height = config.height;
                this.image = assets[config.id];
                this.x = canvas.width; // Start off-screen right
                this.y = GROUND_Y - this.height;
                this.speedFactor = config.speedFactor;
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            update() {
                this.x -= gameSpeed * this.speedFactor;
            }

            // Simple Axis-Aligned Bounding Box (AABB) collision check
            checkCollision(player) {
                return (
                    this.x < player.x + player.width &&
                    this.x + this.width > player.x &&
                    this.y < player.y + player.height &&
                    this.y + this.height > player.y
                );
            }
        }


        // --- 4. GAME LOGIC & LOOP ---

        /** The main game loop function. */
        function gameLoop() {
            if (isGameOver) return;

            // 1. Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Update Game State
            gameFrame++;
            score += Math.floor(gameSpeed * 0.1); // Score based on speed/time
            gameSpeed = Math.min(GAME_CONFIG.gameSettings.maxGameSpeed, gameSpeed + GAME_CONFIG.gameSettings.speedIncreaseRate);
            scoreDisplay.textContent = `SCORE: ${score}`;

            // 3. Spawn Obstacles
            if (gameFrame > nextObstacleFrame) {
                const randomConfig = GAME_CONFIG.obstacles[Math.floor(Math.random() * GAME_CONFIG.obstacles.length)];
                obstacles.push(new Obstacle(randomConfig));
                
                // Set next spawn frame
                const min = GAME_CONFIG.gameSettings.obstacleSpawnIntervalMin;
                const max = GAME_CONFIG.gameSettings.obstacleSpawnIntervalMax;
                nextObstacleFrame = gameFrame + min + Math.random() * (max - min);
            }

            // 4. Update & Draw Player
            player.update();
            player.draw();

            // 5. Update & Draw Obstacles
            obstacles.forEach((obstacle, index) => {
                obstacle.update();
                obstacle.draw();

                // Check Collision
                if (obstacle.checkCollision(player)) {
                    // Collision detected! Game Over
                    endGame();
                }

                // Remove obstacles that move off-screen
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(index, 1);
                }
            });
            
            // 6. Request Next Frame
            requestAnimationFrame(gameLoop);
        }

        /** Resets and starts the game. */
        function startGame() {
            if (!assetsLoaded) return; // Wait for assets to load

            // Reset state
            isGameRunning = true;
            isGameOver = false;
            gameFrame = 0;
            score = 0;
            gameSpeed = GAME_CONFIG.gameSettings.initialGameSpeed;
            obstacles = [];
            
            handleResize(); 

            // Reset player position and state for the new game
            player.y = player.groundY; 
            player.isJumping = false;
            player.jumpVelocity = 0;

            messageBox.classList.add('opacity-0', 'pointer-events-none');
            restartButton.classList.add('hidden');
            
            // Start the loop
            gameLoop();
        }

        /** Stops the game and displays game over message. */
        function endGame() {
            isGameRunning = false;
            isGameOver = true;

            // Display Game Over screen
            messageTitle.textContent = "GAME OVER!";
            messageBody.textContent = `You achieved a Buyout Score of: ${score}`;
            messageBox.classList.remove('opacity-0', 'pointer-events-none');
            restartButton.classList.remove('hidden');
        }

        // --- 5. INPUT HANDLERS ---
        
        function handleKeyDown(event) {
            if (event.code === 'Space') {
                console.log("Spacebar pressed. isGameRunning:", isGameRunning); // DEBUGGING LOG
                event.preventDefault(); // Prevent page scrolling
                if (!isGameRunning && !isGameOver) {
                    startGame();
                } else if (isGameRunning) {
                    // Ensure player exists before attempting to jump
                    if (player) {
                        player.jump();
                    }
                }
            }
        }

        function handleTouch(event) {
            if (!isGameRunning && !isGameOver) {
                startGame();
            } else if (isGameRunning) {
                if (player) {
                    player.jump();
                }
            }
        }
        
    </script>
</body>
</html>
